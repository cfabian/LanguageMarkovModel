package markovModel;

import java.io.*;
import java.util.*;
import java.lang.Long;

public class MarkovModel<T> {
    

    class IndexFrequencyPair
    {
        public IndexFrequencyPair(int index, int freq)
        {
            this.index = index;
            this.freq = freq;
        }
        public int index;
        public int freq; 
    }
    protected HashMap<String, IndexFrequencyPair> string_to_index = new HashMap<String, IndexFrequencyPair>();
    protected Matrix<Double> m_probabilities = null;
    // protected Matrix<Double> m_layer_2_markov_model = null;
    
    
    protected List<String> wordMap = null;   
    protected Vector<Vector<Integer>> frequencies = new Vector<Vector<Integer>>();
    protected Vector<Vector<Double>> probabilities = new Vector<Vector<Double>>();
    
    public MarkovModel(String fileName) {
        String[] words = WordParser(fileName);
        // for(int i = 0; i < words.length; i++)
        // {
        //     System.err.println(words[i]);
        // }
        makeModel(words);
        // prettyPrint(1, 0, 15, 0, 15);
    }
    
    public String generateText(int number_of_words) {
        String text = "";
        int min = 0;
        int max = string_to_index.size() - 1;
        Random rand = new Random();
        int word = rand.nextInt((max - min) + 1) + min;
        
        
        // Gets the first word, each has an equal probability. Essentially.
        // System.out.printf("%s", wordMap.get(word).substring(0, 1).toUpperCase() + wordMap.get(word).substring(1));
        text += wordMap.get(word).substring(0, 1).toUpperCase() + wordMap.get(word).substring(1);
        
        double random_number = 0.0;
        double probability_sum = 0.0;
        int previous_word_index = word;
        for(int i = 0; i < number_of_words; i++)
        {
            random_number = rand.nextDouble();
            probability_sum = 0.0;
            // Can probably speed this up if we precompute the sums and then 
            // perform a modified binary search.
            for(int j = 0; j < m_probabilities.getNumberOfColumns(); j++)
            {
                probability_sum += m_probabilities.at(previous_word_index, j);
                if(probability_sum >= random_number)
                {
                    // System.out.printf(" %s", wordMap.get(j));
                    text += " " + wordMap.get(j);
                    previous_word_index = j;
                    break;
                }
            }
        }
        // for(int i = 0; i < length; i ++) {
        //     Double randNum = rand.nextDouble();
        //     Double s = 0.0;
        //     for(int j = 0; j < probabilities.size(); j ++) {
        //         s += probabilities.get(j).get(word);
        //         if(s >= randNum) {
        //             System.out.printf(" %s", wordMap.get(j));
        //             word = j;
        //             break;
        //         }
        //     }
        // }
        // System.out.printf(".\n");
        text += ".";
        
        return text;
    }
    
    protected String[] WordParser(String fileName) {
        // System.out.println(fileName);
        String content = "";
        
        try {
            content = new Scanner(new File(fileName)).useDelimiter("\\Z").next().trim().replaceAll("[-–\".,!?&;:*><©=)(/]{1,}", "").replaceAll("\\s{2,}", " ").toLowerCase();
            
        } catch(Exception e) {
            e.printStackTrace();
            
        }
        return content.split("[ \n]");
    }
    

    protected void makeModel(String[] words) {

        // Overpopulate the string list (Probably a bad idea).
        wordMap = new ArrayList<String>(words.length); 
        // Populate the indicies first then, actually
        for(String i : words)
        {
            if(string_to_index.containsKey(i))
            {
                IndexFrequencyPair temp = string_to_index.get(i);
                temp.freq += 1;
            }
            else
            {
                wordMap.add(string_to_index.size(), i);                
                string_to_index.put(i, new IndexFrequencyPair(string_to_index.size(), 1));
            }
        }
        
        // Make a 2d matrix
        m_probabilities = new Matrix<Double>(string_to_index.size(), string_to_index.size());
        // m_probabilities.fillMatrixWithDefaultConstructors(Double.class);
        // Need to populate the matrix with default values.
        for(int i = 0; i < m_probabilities.getNumberOfRows(); i++)
            for(int j = 0; j < m_probabilities.getNumberOfColumns(); j++)
                m_probabilities.set(i, j, new Double(0.0));
        IndexFrequencyPair current = null;
        IndexFrequencyPair prev = string_to_index.get(words[0]); // Get the index for the first word.
        for(int i = 1; i < words.length; i++)
        {
            current = string_to_index.get(words[i]); // Get the index/frequency for the next word.
            // System.err.println("i: " + Integer.toString(prev.index) + "    j: " + Integer.toString(current.index));
            m_probabilities.set(prev.index, current.index, m_probabilities.at(prev.index, current.index) + (1.0/prev.freq)); // Add the frequency to the pairing.
            prev = current;
        }

        // Need to do a sum division of the frequencies. (Maybe)
        // for(int i = 0; i < m_probabilities.getNumberOfRows(); i++)
        // {
        //     for(int j = 0; j < m_probabilities.getNumberOfColumns(); j++)
        //     {

        //     }
        // }
        // What the hell does this line do.
        // frequencies.get(wordMap.indexOf(words[i])).set(wordMap.indexOf(words[i - 1]), frequencies.get(wordMap.indexOf(words[i])).get(wordMap.indexOf(words[i - 1])) + 1);

        
        // Dont need this
        // int count = 0;
        
        // for(int i = 0; i < frequencies.size(); i ++) {
        //     for(int j = 0; j < frequencies.size(); j ++) {
        //         count += frequencies.get(j).get(i);
        //     }
            
        //     for(int j = 0; j < frequencies.size(); j ++) {
        //         if(frequencies.get(j).get(i) > 0) {
        //             probabilities.get(j).set(i, ((double)frequencies.get(j).get(i) / (double)count));
        //         }
        //     }
        //     count = 0;
        // }

        // m_layer_2_markov_model = squareMatrix();
    }
    
    protected void saveModel() {
        FileOutputStream f1 = null;
        FileOutputStream f2 = null;
        FileOutputStream f3 = null;
        try {
            f1 = new FileOutputStream("wordMap.txt");
            f2 = new FileOutputStream("frequencies.txt");
            f3 = new FileOutputStream("probabilities.txt");
            
            for(int i = 0; i < wordMap.size(); i ++) {
                f1.write((wordMap.get(i)).getBytes());
                if(i != wordMap.size() - 1) {
                    f1.write((",").getBytes());
                }
            }
            
            for(int i = 0; i < frequencies.size(); i ++) {
                for(int j = 0; j < frequencies.size(); j ++) {
                    f2.write((frequencies.get(i).get(j)).toString().getBytes());
                    if(j != frequencies.size() - 1) {
                        f2.write((",").getBytes());
                    } else {
                        f2.write(("\n").getBytes());
                    }
                }
            }
        }catch(IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if(f1 != null) {
                    f1.close();
                }
            }catch(IOException e) {
                System.out.println("Error closing file");
            }
        }
    }
    
    protected Matrix<Double> squareMatrix()
    {
        long startTime = System.nanoTime();

        System.err.println("Squaring a matrix of dimenstions " + Integer.toString(m_probabilities.getNumberOfRows()) + "x" + Integer.toString(m_probabilities.getNumberOfColumns()));
        Matrix<Double> rv = new Matrix<Double>(m_probabilities.getNumberOfRows(), m_probabilities.getNumberOfColumns());
        for(int i = 0; i < m_probabilities.getNumberOfRows(); i++)
            for(int j = 0; j < m_probabilities.getNumberOfColumns(); j++)
                m_probabilities.set(i, j, new Double(0.0));

        double sum;
        for(int i = 0; i < rv.getNumberOfRows(); i++)
        {
            for(int j = 0; j < rv.getNumberOfColumns(); j++)
            {
                sum = 0;
                for(int k = 0; k < rv.getNumberOfRows(); k++)
                {
                    sum += m_probabilities.at(i, k) * m_probabilities.at(k, j);
                }
                rv.set(i, j, sum);
            }
        }

        long endTime   = System.nanoTime();
        long totalTime = endTime - startTime;
        System.err.println("Time took to square matrix: " + Long.toString(totalTime));
        return rv;
    }
    protected void prettyPrint(int matrix, int x1, int x2, int y1, int y2) {
        System.out.printf("%12s", " ");
        
        for(int i = x1; i < x2; i ++) {
            System.out.printf("%12s", wordMap.get(i));
        }
        
        System.out.printf("\n");
        
        for(int i = y1; i < y2; i ++) {
            System.out.printf("%12s", wordMap.get(i));
            for(int j = x1; j < x2; j ++) {
                // if(matrix == 0) {
                    // System.out.printf("%12d", frequencies.get(i).get(j));
                    // System.out.printf("%12d", string_to_index.get(word_Map.get(i)).index string_to_inde frequencies.get(i).get(j));
                // } else {
                    System.out.printf("%12f", m_probabilities.at(i, j));
                // }
            }
            System.out.printf("\n");
        }
    }
}